<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>R workshop</title>
    <meta charset="utf-8" />
    <meta name="author" content="Bolin Wu" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/ki.css" rel="stylesheet" />
    <link href="libs/remark-css/ki-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# R workshop
]
.subtitle[
## Data manupulation &amp; Rmarkdown
]
.author[
### Bolin Wu
]
.institute[
### NEAR, Aging Research Center
]
.date[
### 2023/01/26 (updated: 2023-02-01)
]

---







---

## About me 

.pull-left[

![](pic/Bolin_pic.png)
] 

.pull-left[

- Statistician at [NEAR](https://www.near-aging.se/), KI.
- MSc in Statistics, Uppsala University.
- Interests: 
  - R package dev
  - Statistics
  - Data manipulation
  - guitar
]



---
## `workshopr` package

### Install

```r
install.packages("remotes")
remotes::install_github("Bolin-Wu/workshopr",
  subdir = "rpackage",
  force = TRUE
)
```


### Load

```r
library(workshopr)
library(tidyverse)
```

---
class: center, middle

# Data manupulation

### tidyverse, assign

---
## Introduction

This session is to share useful data manipulation skills at daily epidemiology work. My main goal is to follow the "don't repeat yourself" (DRY) principle. 

It can make our code more readable and reduce our chance of making mistakes.

--

*Note: Data frames may seem to be unfit in the slides. I do not user any html widges since the code will be pulled out for tutorial purpose. Attendants can run the code on their on machine instead to get better view.*


???

For example, change a variable name in the code, but forget to change other places

---

## Content

The content is selected based on data manipulation in real work scenario.

I hope by the end of the workshop, you will have them in your toolbox:

- %&gt;% syntax
- **join** data frames (*join function*)
- **transform** data shape (*pivot_longer*)
- **filter** variables based on name pattern (*select*)
- **extract** the label from DTA and SPSS in R (*filter*)
- **check** missing values (*summarise &amp; across*)
- **mutate data** based on column types (*mutate &amp; across*)
- **bin** variables by percentiles (*cut*)
- **assign** function

---

background-image: url(https://1.bp.blogspot.com/-UHpM76ze7Dk/YFVs4iGMWuI/AAAAAAAAA0s/3EpcYcl-PLce7rcdcD4YOUXntpdUbc3aACLcBGAsYHQ/s16000/7b5f79a7e88560bb863c6bc8bcfb7146.jpg)

.footnote[picture credit: https://www.redarmy.in/]


---

# Tidyverse


Many times we just `library(tidyverse)`. Actually [Tidyverse](https://www.tidyverse.org/packages/) is a huge umbrella consists of several powerful visualization and data manipulation package. For example:

- [magrittr](https://magrittr.tidyverse.org/): pipeline operator `%&gt;%`.
- [ggplot2](https://ggplot2.tidyverse.org/): `ggplot()`.
- [dplyr](https://dplyr.tidyverse.org/): `select(), filter(), mutate()`.
- [stringr](https://stringr.tidyverse.org/): `str_detect(), str_subset()`.

--

### Notes

- Advantage: All at once.
- Disadvantage: 
  - Slower to load the whole package. 
  - Potential conflicts of function names with other packages. Example [here](https://tidyverse.tidyverse.org/reference/tidyverse_conflicts.html).

???

Just heads up, in case in the future you find one function does not work as it expected. Then you know it could because of the conflicts of tidyverse.

---

## Pipeline operator `%&gt;%`
Beautiful syntax with pipeline, just like playing LEGO.

![](pic/legos.jpg)

---

### Example


```r
fake_snack_df %&gt;%
  select(Lopnr, Date_wave1)
```

```
# A tibble: 3,365 x 2
   Lopnr Date_wave1
   &lt;int&gt; &lt;date&gt;    
 1  1284 1848-01-16
 2  2013 1788-07-16
 3  1618 1833-09-17
 4  3190 1803-04-08
 5  1103 1705-06-10
 6  2193 1733-11-07
 7  2555 1792-08-31
 8   254 1768-04-16
 9  2250 1810-02-09
10  2258 1722-08-02
# ... with 3,355 more rows
```

---

- In addition, filter on the date column


```r
fake_snack_df %&gt;%
  select(Lopnr, Date_wave1) %&gt;%
  filter(Date_wave1 &gt; "1800-01-01") %&gt;%
  slice(1:5)
```

```
# A tibble: 5 x 2
  Lopnr Date_wave1
  &lt;int&gt; &lt;date&gt;    
1  1284 1848-01-16
2  1618 1833-09-17
3  3190 1803-04-08
4  2250 1810-02-09
5  2835 1813-12-12
```

--

- You can further stacking group, filter, mutate, etc., with the pipeline operator.

???
This syntax makes data manupulation convenient and easy to read.

---
## Join data frames


* With `.*_join()` function: There are 4 common types of joins.


![](pic/join_tabel.png)

---

- Take `left_join()` as an example: 


```r
# From  `dplyr` documentation:
df1 &lt;- tibble(x = 1:3)
df2 &lt;- tibble(
  x = c(1, 1, 2),
  y = c("first", "second", "third")
)
df1 %&gt;% left_join(df2)
```

```
Joining, by = "x"
```

```
# A tibble: 4 x 2
      x y     
  &lt;dbl&gt; &lt;chr&gt; 
1     1 first 
2     1 second
3     2 third 
4     3 &lt;NA&gt;  
```

???
Please note, in this example, df1 is on the left side.



---
## Transform data shape
Transform data shape is frequently used to clean data. However, for many people, including me, it sounds troublesome. In R, its relevant functions are evolving overtime as well.

--

In the beginning (2019), I used [spread()](https://tidyr.tidyverse.org/reference/spread.html) and [gather()](https://tidyr.tidyverse.org/reference/gather.html).  Every time I use `spread()` and `gather()`, it takes me a while to figure out how to fill in 'key' and 'value'. But as you can see from their documentation, their 'lifecycle' is 'superseded'.

---
## Transform data shape

Now I only use `pivot_longer()` and `pivot_wider()` for transforming data. You can find their comprehensive documentation [here](https://tidyr.tidyverse.org/articles/pivot.html). 

--

They come with better documentation, more powerful application, and better integration with tidyverse syntax.

---

### Example

Let's assume we received a wide format data:


```r
head(fake_snack_df, n = 5)
```

```
# A tibble: 5 x 15
  Lopnr    sex Date_wave1 education Date_wave2 Date_wave3 Date_wave4 Date_wave5
  &lt;int&gt;  &lt;dbl&gt; &lt;date&gt;         &lt;dbl&gt; &lt;date&gt;     &lt;date&gt;     &lt;date&gt;     &lt;date&gt;    
1  1284 -1.62  1848-01-16   -1.00   1703-06-26 1807-08-10 1764-12-13 1774-04-04
2  2013  0.384 1788-07-16    0.883  1785-09-24 1811-08-26 1812-05-24 1777-11-08
3  1618 -0.363 1833-09-17    0.0753 1792-10-19 1781-01-06 1746-09-20 1804-04-12
4  3190  0.682 1803-04-08    0.0943 1829-04-27 1744-02-04 1846-08-24 1766-03-26
5  1103  0.521 1705-06-10    1.37   1734-12-24 1746-03-13 1829-11-30 1711-02-15
# ... with 7 more variables: Date_wave6 &lt;date&gt;, dementia_wave1 &lt;dbl&gt;,
#   dementia_wave2 &lt;dbl&gt;, dementia_wave3 &lt;dbl&gt;, dementia_wave4 &lt;dbl&gt;,
#   dementia_wave5 &lt;dbl&gt;, dementia_wave6 &lt;dbl&gt;
```

???
Please run the code in your R studio to get a better view.
---

### Example

The column names are:


```r
sort(colnames(fake_snack_df))
```

```
 [1] "Date_wave1"     "Date_wave2"     "Date_wave3"     "Date_wave4"    
 [5] "Date_wave5"     "Date_wave6"     "dementia_wave1" "dementia_wave2"
 [9] "dementia_wave3" "dementia_wave4" "dementia_wave5" "dementia_wave6"
[13] "education"      "Lopnr"          "sex"           
```

--

Now, assume for some reason, e.g. merge it with other data set, we want to transform it in a long format. 

--

There are two variables with prefix should be formatted: 'Date' and 'dementia'. For beginners, I would recommend to start small. 

---
### Example
- Select the interested columns


```r
fake_snack_df %&gt;%
  select(contains("Date")) %&gt;%
  slice(1:5)
```

```
# A tibble: 5 x 6
  Date_wave1 Date_wave2 Date_wave3 Date_wave4 Date_wave5 Date_wave6
  &lt;date&gt;     &lt;date&gt;     &lt;date&gt;     &lt;date&gt;     &lt;date&gt;     &lt;date&gt;    
1 1848-01-16 1703-06-26 1807-08-10 1764-12-13 1774-04-04 1739-04-12
2 1788-07-16 1785-09-24 1811-08-26 1812-05-24 1777-11-08 1825-04-20
3 1833-09-17 1792-10-19 1781-01-06 1746-09-20 1804-04-12 1764-11-26
4 1803-04-08 1829-04-27 1744-02-04 1846-08-24 1766-03-26 1735-06-10
5 1705-06-10 1734-12-24 1746-03-13 1829-11-30 1711-02-15 1710-06-12
```

---
### Example

Read documentation, try to fill in the arguments. 

```r
?tidyr::pivot_longer()
```

--

- The 3 basic arguments are:
  * `cols()`: tells R what variables to pivot.
  * `names_to()`:  a new name for columns in `cols()`. 
  * `values_to()`: a new name for **values** under the columns in `cols()`.

---

### Example
Let's give a first try:

  

```r
fake_snack_df %&gt;%
  select(Lopnr, contains("Date")) %&gt;%
  pivot_longer(
    cols = contains("Date"),
    names_to = "wave", values_to = "date",
    names_prefix = "Date"
  )
```

```
# A tibble: 20,190 x 3
   Lopnr wave   date      
   &lt;int&gt; &lt;chr&gt;  &lt;date&gt;    
 1  1284 _wave1 1848-01-16
 2  1284 _wave2 1703-06-26
 3  1284 _wave3 1807-08-10
 4  1284 _wave4 1764-12-13
 5  1284 _wave5 1774-04-04
 6  1284 _wave6 1739-04-12
 7  2013 _wave1 1788-07-16
 8  2013 _wave2 1785-09-24
 9  2013 _wave3 1811-08-26
10  2013 _wave4 1812-05-24
# ... with 20,180 more rows
```


---

### Example

The result above looks good, but 'wave' looks a bit strange. I will leave the task to audience to fix this column.


--
* Do the same with 'dementia' columns

--


```r
fake_snack_df %&gt;%
  select(Lopnr, contains("dementia")) %&gt;%
  pivot_longer(
    cols = contains("dementia"),
    names_to = "wave", names_prefix = "dementia",
    values_to = "dementia"
  )
```

```
# A tibble: 20,190 x 3
   Lopnr wave   dementia
   &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;
 1  1284 _wave1   -0.246
 2  1284 _wave2   -0.704
 3  1284 _wave3   -0.508
 4  1284 _wave4   -1.48 
 5  1284 _wave5   -0.402
 6  1284 _wave6    1.37 
 7  2013 _wave1    0.377
 8  2013 _wave2    0.832
 9  2013 _wave3   -0.824
10  2013 _wave4    2.37 
# ... with 20,180 more rows
```

???
Pay attention to what arguments are changed, what are not changed.

---

### Data transform exercise (5 - 10 min)

- Read documentation. Change the arguments in the `pivot_longer()` function to get proper wave column. 

*Example result (first 5 rows):*


```
# A tibble: 5 x 3
  Lopnr wave  date      
  &lt;int&gt; &lt;fct&gt; &lt;date&gt;    
1  1284 1     1848-01-16
2  1284 2     1703-06-26
3  1284 3     1807-08-10
4  1284 4     1764-12-13
5  1284 5     1774-04-04
```

--

- Merge the two long pivot data sets together. 

*Consider: is it enough to only join on one column? Why or why not?*

---

## Select variables by name pattern

Some times you get data with specific variables. E.g.

- Each wave has its own specific prefix.
- Questionnaire/in person test has its own prefix.
- ...

--

In this case, the `select()` function can help you. Some useful **selection helpers** are

- `starts_with()`
- `contains()`
- `matches()`
- ...

More details please see documentation:

```r
?select()
```

???
Explain them. 90% of the time I just use these four.

---

### starts_with


```r
fake_snack_df %&gt;%
  select(starts_with("Date"))
```

### contains


```r
fake_snack_df %&gt;%
  select(contains("Date") &amp; contains("wave"))
```

--

- Imagine if only using `contains('Date')` without '&amp;' operator. What result would look like? Then try it.

---

### match

- `match()` is more advanced since it uses [regular expression (regex)](https://en.wikipedia.org/wiki/Regular_expression). 

--

- There are many regex cheatsheets online. For exmaple [this](https://www.rexegg.com/regex-quickstart.html).

--

- One useful website to test regex is [here](https://regex101.com).


```r
fake_snack_df %&gt;%
  select(matches("Date_wave\\d"))
```


???

With match basically you can filter any pattern of variable names you want.

I can show to test it in the online test website.


---

## Get labels from datasets

- When we get SPSS or STATA data sets, usually they come with labels. E.g. in SPSS, one can check them in the "Variable View" tab. 

--

- In R, one can use `view()` function. In the example data, we have:


```r
view(fake_snack_df)
```


![](pic/df_label.png)

--

- A natural question to ask: how to extract the labels in R?

???
This can be useful when you got hundreds of variables in a file.

There's one project has 200+ variables, I need to select the variables related to smoking.


---

If you run `str()` function, the labels are in the "label" attribute. There are multiple ways to extract the labels.


```r
str(fake_snack_df)
```

--

The one I use is the [sjlabelled](https://strengejacke.github.io/sjlabelled/articles/labelleddata.html) R package.


```r
label_char &lt;- sjlabelled::get_label(fake_snack_df)
label_char
```

```
                       Lopnr                          sex 
                        "ID"                     "gender" 
                  Date_wave1                    education 
"date examination 2001-2004"                  "education" 
                  Date_wave2                   Date_wave3 
"date examination 2004-2007" "date examination 2007-2010" 
                  Date_wave4                   Date_wave5 
"Date examination 2010-2013" "Date examination 2013-2016" 
                  Date_wave6               dementia_wave1 
"Date examination 2016-2019"         "dementia 2001-2004" 
              dementia_wave2               dementia_wave3 
        "dementia 2004-2007"         "dementia 2007-2010" 
              dementia_wave4               dementia_wave5 
        "dementia 2010-2013"         "dementia 2013-2016" 
              dementia_wave6 
        "dementia 2016-2019" 
```


|               |x                          |
|:--------------|:--------------------------|
|Lopnr          |ID                         |
|sex            |gender                     |
|Date_wave1     |date examination 2001-2004 |
|education      |education                  |
|Date_wave2     |date examination 2004-2007 |
|Date_wave3     |date examination 2007-2010 |
|Date_wave4     |Date examination 2010-2013 |
|Date_wave5     |Date examination 2013-2016 |
|Date_wave6     |Date examination 2016-2019 |
|dementia_wave1 |dementia 2001-2004         |
|dementia_wave2 |dementia 2004-2007         |
|dementia_wave3 |dementia 2007-2010         |
|dementia_wave4 |dementia 2010-2013         |
|dementia_wave5 |dementia 2013-2016         |
|dementia_wave6 |dementia 2016-2019         |

---

The result looks terrible, so we have to fix it by transforming it to be tibble:


```r
label_df &lt;- tibble::rownames_to_column(as.data.frame(label_char), "variable")
label_df &lt;- tibble::as_tibble(label_df)
label_df
```

```
# A tibble: 15 x 2
   variable       label_char                
   &lt;chr&gt;          &lt;chr&gt;                     
 1 Lopnr          ID                        
 2 sex            gender                    
 3 Date_wave1     date examination 2001-2004
 4 education      education                 
 5 Date_wave2     date examination 2004-2007
 6 Date_wave3     date examination 2007-2010
 7 Date_wave4     Date examination 2010-2013
 8 Date_wave5     Date examination 2013-2016
 9 Date_wave6     Date examination 2016-2019
10 dementia_wave1 dementia 2001-2004        
11 dementia_wave2 dementia 2004-2007        
12 dementia_wave3 dementia 2007-2010        
13 dementia_wave4 dementia 2010-2013        
14 dementia_wave5 dementia 2013-2016        
15 dementia_wave6 dementia 2016-2019        
```

---

The result looks much better! Now we can do lots of things with pipeline.

- filter the label contains 'dementia'


```r
label_df %&gt;%
  filter(grepl("dementia", label_char))
```

```
# A tibble: 6 x 2
  variable       label_char        
  &lt;chr&gt;          &lt;chr&gt;             
1 dementia_wave1 dementia 2001-2004
2 dementia_wave2 dementia 2004-2007
3 dementia_wave3 dementia 2007-2010
4 dementia_wave4 dementia 2010-2013
5 dementia_wave5 dementia 2013-2016
6 dementia_wave6 dementia 2016-2019
```

---

- filter the variable contains 'wave'


```r
label_df %&gt;%
  filter(grepl("wave", variable))
```

```
# A tibble: 12 x 2
   variable       label_char                
   &lt;chr&gt;          &lt;chr&gt;                     
 1 Date_wave1     date examination 2001-2004
 2 Date_wave2     date examination 2004-2007
 3 Date_wave3     date examination 2007-2010
 4 Date_wave4     Date examination 2010-2013
 5 Date_wave5     Date examination 2013-2016
 6 Date_wave6     Date examination 2016-2019
 7 dementia_wave1 dementia 2001-2004        
 8 dementia_wave2 dementia 2004-2007        
 9 dementia_wave3 dementia 2007-2010        
10 dementia_wave4 dementia 2010-2013        
11 dementia_wave5 dementia 2013-2016        
12 dementia_wave6 dementia 2016-2019        
```



---

## Missing values


### Count the NA

- If count the NA of one column. It could something like:


```r
sum(is.na(fake_snack_df$Date_wave1))
```

```
[1] 0
```
--

- What if multiple columns?

---

### Count NA in multiple columns


```r
fake_snack_df %&gt;%
  summarise(across(
    where(lubridate::is.Date),
    ~ sum(is.na(.))
  ))
```

```
# A tibble: 1 x 6
  Date_wave1 Date_wave2 Date_wave3 Date_wave4 Date_wave5 Date_wave6
       &lt;int&gt;      &lt;int&gt;      &lt;int&gt;      &lt;int&gt;      &lt;int&gt;      &lt;int&gt;
1          0          0          0          0          0          0
```

- You may wonder: what is this `~ sum(is.na(.))`?

--

- It is a purrr-style [lambda function](https://en.wikipedia.org/wiki/Anonymous_function).

???
The wikipedia explanation is not straight-forward. My personal comprehension is that lambda function is any function you defined by yourself, which usually can not be found as a standard function like mean or sd.

--

- One can also use `colSums(is.na(fake_snack_df))`. 

???
Explain why I prefer the pipeline version


---

## Missing value exercise (5 - 10 min)

- Read the documentation of `across()` function.
- Count the NA of all numeric/int columns.
- Count the NA of columns contains certain strings, e.g. 'edu'

*Example result*


```
# A tibble: 1 x 9
  Lopnr   sex education dementia_wave1 dementi~1 demen~2 demen~3 demen~4 demen~5
  &lt;int&gt; &lt;int&gt;     &lt;int&gt;          &lt;int&gt;     &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;
1     0     0         0              0         0       0       0       0       0
# ... with abbreviated variable names 1: dementia_wave2, 2: dementia_wave3,
#   3: dementia_wave4, 4: dementia_wave5, 5: dementia_wave6
```

```
# A tibble: 1 x 1
  education
      &lt;int&gt;
1         0
```

---

## Mutation based on column type

- Now you should have some understanding of `where()` function. 

--

- When you apply it with `mutate()` function, you can do many manipulations. E.g. round the digits of numeric columns.

--


```r
fake_snack_df %&gt;%
  mutate(across(is.numeric, ~ round(., digits = 2)))
```

```
Warning: Use of bare predicate functions was deprecated in tidyselect 1.1.0.
i Please use wrap predicates in `where()` instead.
  # Was:
  data %&gt;% select(is.numeric)

  # Now:
  data %&gt;% select(where(is.numeric))
```

```
# A tibble: 3,365 x 15
   Lopnr   sex Date_wave1 education Date_wave2 Date_wave3 Date_wave4 Date_wave5
   &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt;         &lt;dbl&gt; &lt;date&gt;     &lt;date&gt;     &lt;date&gt;     &lt;date&gt;    
 1  1284 -1.62 1848-01-16     -1    1703-06-26 1807-08-10 1764-12-13 1774-04-04
 2  2013  0.38 1788-07-16      0.88 1785-09-24 1811-08-26 1812-05-24 1777-11-08
 3  1618 -0.36 1833-09-17      0.08 1792-10-19 1781-01-06 1746-09-20 1804-04-12
 4  3190  0.68 1803-04-08      0.09 1829-04-27 1744-02-04 1846-08-24 1766-03-26
 5  1103  0.52 1705-06-10      1.37 1734-12-24 1746-03-13 1829-11-30 1711-02-15
 6  2193  0.31 1733-11-07      0.77 1794-06-13 1738-06-02 1846-12-28 1750-10-02
 7  2555  1.17 1792-08-31      0.56 1727-07-07 1848-10-20 1807-12-03 1819-11-05
 8   254  1.07 1768-04-16     -0.16 1704-10-02 1773-10-25 1804-09-12 1722-06-18
 9  2250  0.24 1810-02-09     -0.29 1848-05-22 1812-01-08 1730-03-15 1719-02-22
10  2258 -0.06 1722-08-02      1.84 1786-01-17 1845-01-13 1762-03-06 1778-01-19
# ... with 3,355 more rows, and 7 more variables: Date_wave6 &lt;date&gt;,
#   dementia_wave1 &lt;dbl&gt;, dementia_wave2 &lt;dbl&gt;, dementia_wave3 &lt;dbl&gt;,
#   dementia_wave4 &lt;dbl&gt;, dementia_wave5 &lt;dbl&gt;, dementia_wave6 &lt;dbl&gt;
```

???
This I often use for data visualization.

---

## Bin variables

--

- `cut()` function can do the work for us easily, it accommodates well with pipeline syntax.

--

- For example, if we want to bin the education variable.


```r
fake_snack_df %&gt;%
  transmute(education, edu_bin = cut(education,
    breaks = 3,
    labels = c("low", "medium", "high")
  ))
```

```
# A tibble: 3,365 x 2
   education edu_bin
       &lt;dbl&gt; &lt;fct&gt;  
 1   -1.00   medium 
 2    0.883  medium 
 3    0.0753 medium 
 4    0.0943 medium 
 5    1.37   high   
 6    0.771  medium 
 7    0.562  medium 
 8   -0.159  medium 
 9   -0.289  medium 
10    1.84   high   
# ... with 3,355 more rows
```



---

### Assign function

I would like to spend some time introduce `assign()` function in R. 

--

- Even though it is not part of `tidyverse` family. But it is really useful! For example, when you bulk import databases into R environment; or you want to bulk change the imported data frame names.

--

- A simple example (run in your R studio):


```r
df_names &lt;- c()
set.seed(2023)
for (i in 1:4) {
  df_names[i] &lt;- paste0("edu_", i)
  assign(df_names[i], sample.int(3, 10, replace = T))
  # print the result
  cat(
    "The df name is: ", df_names[i], "\n",
    "its value is: ", get(df_names[i]), "\n"
  )
}
```

---

### Messy dataframe name

- Imagine in your environment you have these dataframe. 
  - Chances are that they are named this way when you get the data files from someone. They have spaces, "-", horrible!
  

```r
objects_name &lt;- c(
  "Cohort1_Baseline_BMI", "Cohort1_FU1_BMI", "Cohort1_FU2_BMI",
  "Cohort1FU3_Cohort2FU2", "Cohort2_Baseline_BMI", "envir_name",
  "Gender data request_20230111", "Gender data request_20230116",
  "index", "NEAR_BMI-mortality", "SNAC-K C1 B-F6 cohort file",
  "SNAC-K C1_B", "SNAC-K C1_F1", "SNAC-K C1_F2", "SNAC-K C1_F3",
  "SNAC-K C1_F4", "SNAC-K C1_F5"
)

for (i in 1:length(objects_name)) {
  # assign some values to these objects
  assign(objects_name[i], sample(100,10))
}
```

---

- Look at your 'Environment' panel. Or `ls()` can retrieve all object names in your R environment. Do you feel familiar?

---

### Let's fix it with `assign()` function (one possible way).


```r
clean_names &lt;- gsub(" |-", "_", objects_name)

for (i in 1:length(clean_names)) {
  assign(clean_names[i], get(objects_name[i]))
}

# just show the first few
clean_names[1:5]
```

```
[1] "Cohort1_Baseline_BMI"  "Cohort1_FU1_BMI"       "Cohort1_FU2_BMI"      
[4] "Cohort1FU3_Cohort2FU2" "Cohort2_Baseline_BMI" 
```

--

- Check your 'Environment' panel again.
--

- The `gsub()` part can be customized with regex syntax. Basically you can fix any kind of unclean dataframe names.


---
class: center, middle

# R markdown

## Basics and daily work uses

---

## Introduction

- A complete Rmarkdown documentation could be found [here](https://rmarkdown.rstudio.com/lesson-2.html).
--

- My understanding is: 

**Rmarkdown = markdown + yaml heading + code chunk options.**


---

## Markdown

---

## code chunk options

---

## YAML

```yaml
---
title: "A Cool Presentation"
output: html_document
---
```

---

# Final exercise


- Calculate the NA of all columns except for id column.
- Bin the education variable with your own defined cut points instead of setting the number of bins.
- (optional) Read `stringr` documentation, find appropriate function to filter out 'objects_name' that contains "SNAC".
- (optional) Pivot the original 'fake_snack_df' by using only one `pivot_longer()` function. Put wave and date after 'Lopnr' column. 

*Hint: check the `names_to` argument and `relocate()` function*. 

---


```
# A tibble: 3 x 6
  Lopnr wave  Date         sex education dementia
  &lt;int&gt; &lt;chr&gt; &lt;date&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;
1  1284 wave1 1848-01-16 -1.62     -1.00   -0.246
2  1284 wave2 1703-06-26 -1.62     -1.00   -0.704
3  1284 wave3 1807-08-10 -1.62     -1.00   -0.508
```


---

## Wrap up

* Many times, avoiding repetitive coding can help you, also others to review your code.
--

* In the beginning, the Rmarkdown has steep learning curve, but once you are familiar with it, your life will be easier.
--

* This whole slide is written in Rmarkdown. Check documentation [here](https://github.com/yihui/xaringan). The R example code is pulled from Rmarkdown, I do not need to copy and paste.
--

- Hope today's content could be a useful enlightment to you. If you have any question, please contact me: bolin.wu@ki.se 






    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"contIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
